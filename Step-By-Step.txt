1- Creating a .Net project and using EF. 
2- dotnet new sln to create a solution
3- dotnet new wepapi -n API to create an API folder with relevant code for us. But because I wanted .net 5, I used below command: 
dotnet new webapi --framework "net5.0" -n API
4- dotnet new classlib  --framework "net5.0" -n Application
5- dotnet new classlib  --framework "net5.0" -n Domain
6- dotnet new classlib  --framework "net5.0" -n Persistence
7-dotnet sln add API/API.csproj & Application & Domain & Persistence
8-cd API then dotnet add reference ../Application
8-Add ref to domain and Persistence for pplication. 
9- add ref to domain for Persistence.
10- In domain project delete class1 class and add another class witht the name of Activity
11- install Microsoft.EntityFrameworkCore.SqlServer on Persistence project.
12- Add DataContext to Persistence project. 
13- Derived class from DbContext
14- Add dbcontext into services on startup.cs file in api project. 
15- For adding EF we need tool that we check with this command: dotnet tool list --global.
16- We installed Microsoft.EntityFrameworkCore.Design on API project
17- we use this command to make migration enable:  dotnet ef migrations add InitialCreate -p Persistence -s API
18- Did the changes in the program file of API project.
19- For seeding database, we created a new class in Persistence with the name of seed.cs and then we call seed method from Program.
20- Add a BaseApiController.cs to Controllers folder in API. 
21- Then we added ActvitiesController. 
****************************************** End Of Section 2: API Skeleton ******************************************************
1- Create react app.  React Dev tools. Typescript. Axios. Semantic-ui.
2- create a react app by below command: 
npx create-react-app client-app --use-npm --template typescript
3- We will use Axios to call our API because it is high level and Intercept requests and responses. JS has its http as well, But
it is low level. 
4- In the client-app folder execute npm install axios to install axios.
5- By useState and useEffect we fetch data from API. 
  const [activities, setActivities] = useState([]);

  useEffect(() => {
    axios.get("http://localhost:5000/api/activities").then((response) => {
      console.log(response);
      setActivities(response.data);
    });
  }, []);

  6- We are going to install semantic-ui-react by: npm install semantic-ui-react and npm install semantic-ui-css
  7- import ths line above of the index.tsx : import 'semantic-ui-css/semantic.min.css'
  8- Now we can use semantic ui components. Like Headerm List
****************************************** End Of Section 3: UI Skeleton ******************************************************
1- Looking at clean architecture pattern. CQRS + Mediator pattern
2- Command and Query Responsibility Segregation : Commands do something and Queries just do query DB.
3- Add mediator package to our Application project.  MediatR.Extensions.Microsoft.DependencyInjection
4- In the application project create a folder with the name of activities. 
5- Add a class witht hename of list and add in the class a query class and a handler class implement interface. 
6- Inject datacontext into Handler class. 
7- In the activities controller now we should inject our mediator instead of datacontext. 
8- We add mediator service into startup class.
9- wE MOVED MEDIATOR INJECTING TO OUR BASE API.
10- We added detail, create , edit into mediator and add them to ontroller as well.
11- Now we want to add automapper. So when code get an object and wants to update it, we do not need to write every property.
12- Open nuget galler and search for automapper and install it on application project. 
AutoMapper.Extensions.Microsoft.DependencyInjection
13- in the application project create a new folder and call it core. 
14- Then we add mappingprofile class inherited from profile class from AutoMapper. 
15- In the onstructor we mapp our classes.
16- We add this MappingProfile class to our services in the startup method. 
17- We inject it into handler classes in application project and use it in edit method. 
18- Add an extention to house keeping the startup class.
****************************************** End Of Section 4: CQRS,Mediator,AutoMapper *********************************************
1- Create a CRUD application in React. Folder structure, Typescript Interfaces, Semantiic UI, Basic Forms
2- For our client app folder structure we added 2 folder in src. app=> normal codes features=>specific components
3- move app.css,index.css into app/layout and rename index.css to styles.css
4- adding activity interface. From swagger get the json and use json to ts tool to convert it to ts.
5- in the app folder create another folder with the name of models
6- add Activity.ts and paste the model in there.
7- How we use?In app file where we are using state, we set the type.Now we can remove any from map section. (smart)
8- Add Navbar: From semantic ui will find a navbar. In app/layout we added NavBar.tsx. Use Menu to create a NavBar.
9- For images we added a folder with the name of assets in the public folder. And put files there (logo)
10- we added navbar to our app component. To remove extra div we ued Fragment.
11- Creating an activity dashboard. In app/features we created a new folder with the name of activities.
12- We added activitiesdashboard and its interface to import data from parent to child.
13-We added activityList component.
14- We added a folder to activity with the name of detials. add ActivityDetails component. 
15- For genereate unique id from UI we need to use uuid. npm install uuid
then if we have error for import v4 as uuid we should use: npm i --save-dev @types/uuid
****************************************** End Of Section 5: UI:CRUD *********************************************
1- we will configure Axios to send data from Client side to API. Using genereic types by TS. Axios interceptors. 
2- We are looking to centeralised our axios request. So in the APP folder we added an API folder. 
3- Add a file with the name of agent.ts. We implenet all our api calls in this file. 
4- Adding fake delay: Add sleep into agent file. Use axios interceptors for response to make delay.
5- Add LoadingComponent.tsx into app/layout folder. Use dimmer and loading from semantic ui. 
6- Implementing loading for delete button to show only for one button in list component.
****************************************** End Of Section 6: Connect to API, loading animation ********************
1- MobX : introduce state management. We need to Mobx React Lite. Centeral state management.
2- Why MobX? It is easy with TS. Simpler to read. 
3- MobX use observables. when state changes we can react to that state. 
4= MobX uses classes to save states. 
5- MobX has action and computed property. it has reaction to ract to changes. 
6- When we use MobX, we will create a store which all componentes will have access tohis store.
7- Settin up MobX: npm install mobx mobx-react-lite
8- In the app folder create a new folder with the name of sotres.
9- With MobX we can use different stores instead of one store which is leagcy of react. 
10- Create activityStore.ts in the store folder. Write code.
11- Add store.ts and add required code.
12- In the index.tsx we add our storecontext.prvider tag around app. 
13- We started to clean up app.tsx component. 
14- For making or component observable we should chagen export default of them is observer. 
15- Start to refactoring code to export states from app.tsx to activityStpre. 
16- We are going to use maps instead of array for activitties.
****************************************** End Of Section 7: Change state manager to mobx and activities array to map ********************
1- Why do we need a router? React-Router and React-Router API and history. 
2- React Router. npm install react-router-dom
4- inside the app folder I created router folder. 
5- I created the Routes file and develop it. 
6- For our application to use router we need to replace it with app in index.tsx
7- for testing routing we need some pages to route. I added home in features.
8- We need a router outlet. We swaped         <ActivityDashboard /> in app.tsx with <Outlet/>
9- We move activities loading from home page ( app.tsx) to activities page.
10- Create navlinks in navbar
11- Difference between navlink and link is that navlink 
****************************************** End Of Section 8: Routing **********************************************************************
1- we used reduce function to group activities in the activitylist component.
2- Install react-calendar to use calendar. npm install react-calendar and then npm install @types/react-calendar
3- Then add into index.tsx : import 'react-calendar/dist/Calendar.css' 
****************************************** End Of Section 9: Styling **********************************************************************
1- Error Handling with fluent api. 
2- Install FluentValidation.AspNetCore from nuget gallery on application
3- create a validator class into application project for activity validator.
4- In CQRS pattern we should try to not put our exception handling on the controller side. We should put them in the handler classes.
5- We created the Result class in core folder to return it from handler to api controller.
6- To have a middle ware for our exception handler we added the exception middleware class and add it into program pipeline.
7- npm install react-toastify on the client app.to show error messages. 
8- Add to the head of app.tsx: <ToastContainer position="bottom-right" hideProgressBar theme="colored" />
9- then add import "react-toastify/dist/ReactToastify.min.css"; to index.tsx
10- add axios interceptor to handle exceptions.
 ****************************************** End Of Section 10: Error Handling **********************************************************************
1- Learn to use Formik. Validation with Formik and Yup. 
2- One benefit of Formik is to create reuseable forms. 
3- Install formik: npm install formik (Then we added it into activity form)
4- For validation we need to install Yup. npm install yup and then npm install @types/yup --save-dev
5- we added a MyTextInput component to reuse it. 
6- For date picker we will use react date picker component. npm install react-datepicker and then 
npm install @types/react-datepicker --save-dev
7- then we need to add css for react date picker into index file. 
8- To use type safety for dates, we need to install date-fns. First of all we use the below command to find the version 
which date picker is using: npm ls date-fns the we use the version to install it: npm install date-fns@2.29.3
 ****************************************** End Of Section 11: Formik **********************************************************************
1- ASPNET Core Identity, JWT Token Authentication, Login/Register, Authenticate Requests
2- We want to add Identity to our application. We will Identity to our API project. The API should Authenticate our users. 
3- The API should generate token for us to give to our users. 
4- In the Domain Project, add a class with the name of AppUser. We should derived this class from IdentityUser of
Microsoft Identity Core name space. For this we need to add a package to our project.
5- From nuget galler install ASP.NET Core Identity provider that uses Entity Framework Core. to Domain. 
6-Now we want to make project to scafold needed tables for Identity in DB. (Creating IdentityDbContext)
7- In DataContext class we change the parent class to IdentityDbContext and give the AppUser as generic type. 
we need to install Microsoft AspNetCore Identity to this project(Persistence) as well.
8- Then we should add migration by below command in root directory of our projects: 
dotnet ef migrations add IdentityAdded -p Persistence -s API
9- We need to configure Identity in our startup class. We will get a seperate extension to add our identity configs.
10- In API/Extensions folder we added a new class with the name of IdentityServiceExtensions.
11- then we add services.AddIdentityServices(_config); to our startup class.
12- We need to update the seed to create some users for us. 
13- We added user manager into input parameters of seed data and then we added it from program.cs class.
14- Then we run API project with dotnet run command and the tables and users will add to our DB. 
15- Now we wnat to see how we can login. 
16- We created a folder in our API project with the name of DTOs. User, Login, Register
17- We want to create an account controller. 
18- in our Controllers folder we create a new c# class with the name of AccountController
19- JWT ( JSON Web Token) We want to create a service in our API to provide JWT for us. 
20- We create a new folder in our API folder and call it Services. 
21- Create a new class with the name of TokenService. 
22- We need to install nuget package in our API project: System.IdentityModel.Tokens.Jwt
23- When we created createToken method, we will use it in our account controller.
24- We need to add a service in our service in our IdentityServiceExtensions
            services.AddScoped<TokenService>(); 
25- when our http request comes in, token service will create a new instance and when http request is finished 
it will dispose it. 
26- Now we can inject it into our account controller. 
27- We inject it and we use it to generate the Token. 
28- Now we want to add Token check in out API for when a request is receiveing. 
29- We need another package because we need to Authenticate the token which we are passing in the header of each request.
30- Install Microsoft.AspNetCore.Authentication.JwtBearer on API project. 
31- we configure service.addauthentication in identity extension service. 
32- Then we add middleware to our startup class exactly before useAuthorization:
            app.UseAuthentication();
33- Then for each method in controller that we add authorize it will check the header for token. 
34- add a key in our appsetting development json file for token.
35- Autthorization Policy: We want to make all of our methods authrise instead of account controller. 
36- we need to add some options to addcontroller service in startup file.
37- add     [AllowAnonymous] to account controller. 
38- Creating the registration method. 
39- Add data anotations to registerdto to vaildate it. 
40- Creating the current user. add to account controller getcurrentuser. 
41- We moved AllowAnonymous from top to each method in account controller.
 ****************************************** End Of Section 12: Identity **********************************************************************
1- Client side login and register. 
2- Axios interceptors, MobX reactions, Form submission errors, Modals.
3- add users folder into features. 
4- add login form.
5- add user.ts into model folder. 
6- add Account into our agent.
7- creating user store. 
 ****************************************** End Of Section 13: Client Side Login *************************************
1- EF Relationships, Loading related entity, AutoMapper queryable extensions and adding an infrastructure. 
2- Implimenting a many-to-many Relationships between 2 entity.
3- On activity class we added ICollection<AppUser> and in App user we add ICollection<Activity>
4- Because we wanted to add extra field in our middle table we created a new class for joint table. 
5- We replace the ICollection in Appuser and Activity to mention new table. 
6- Now we need to add some configurations in our DbContext.
7- Added a new db et in data context and override the on model creating.
8- We added a new project as infrastructure to handle add user to activity. in the root folder:
   dotnet new classlib -n Infrastructure 
9- execute: dotnet sln add Infrastructure
10- add a reference of Application to Infrastructure: We should go to Infrastructure folder and execute: 
dotnet add reference ../Application
11- Then API project should have access to Infrastructure. So, in the API folder we execute below command: 
dotnet add reference ../Infrastructure
12- In Application project we add a new folder with the name of interfaces.
13- Add a new interface in the interfaces folder with the name od IUserAccessor.
14- Delete the class1 from infrastructure and add a folder with the name of Security.
15- Add a class with the name of UserAccessor and derived from IUserAccessor.
16- for making infrastrcuture refrences, we go to root folder and execute dotnet restore.
17- So now we have an interface and a service to get username. We need to add them to them API services.
18- We open application service extensions.
            services.AddHttpContextAccessor();
            services.AddScoped<IUserAccessor,UserAccessor>();
19- Now we should update create activity handler. 
20- inside create class we add useaccessor to constructoe.
21- For loading our related data to activity we should tell EF to return our data. 
22- The Lazy Loading is not efficient. We use Eagrly loading. We use .Include in our queries. 
23- We go to our list handler and add include queries.
24- Because we need infinite loop we need to shape our data.
25- in application/activities folder we add  ActivityDto.
26- We add profiles folder and class in Application project.
27- We add property of profile to ActivityDto and hostusername. 
28- in list instead of returning Activity, now we should return ActivityDto. 
29- For creating a list of activity dto automatically, we will use automapper.
30- In application/core we have mappingprofile. we added a new property.    
         CreateMap<Activity, ActivityDto>();
31- we add IMapper to handler list class. and we mapp acticites to activity dto in Handle class.
32- To config automapper to return profiles we config in in automapper. 
33- Because we want to make our queries which are going to DB to bemore efficient, instead of eager loading, 
we are going to use projection. 
34- We changed details to use activitydto and automaper projection as well. 
35- we want to give the host permisiion to canncel the activity. So we annd to add property.
36- we added a new boolean to activity class witht he name of IsCanceled and add migration. 
dotnet ef migrations add AddCancelledProperty -p Persistence -s API
37- We added it to activitydto as well. 
38- To implement cancelling, remove from activity, and join activity, we addded UpdateAttendance handler to activites.
39- Then we go to controller and add a new end point for this functionality. 
40- We want to add a new auth policy to check if the activity is for host, then he can edit it only.
41- In the Infrastructure project and ecurity folder, we created IsHostRequirement class.
42- Then in identity service extension we need to add this new class in our services.
43- Then we add a new end point to our activity controller.
44- Change the seed class to all activities have attendees. Then we drop the database and re run the application. 
****************************************** End Of Section 14: EntityFramework Relationships *******************************
1- In this section we will work on frontend for client side attendance.
2- First step is to create ActivityListItemAttendee component in the front end application. (src/features/activites/dashboard)
3- Then in the activityListItem component in the secondary section we add this new component.
4- For adding user profiles in the model folder in client-app we add profile.ts file.
5- Then we go to activity.ts and add some new properties. 
6- Then in the ActivityListItemAttendee we add props and call it attendees as type prfile array.
7- Now we want to show attendees in the side bar component.
8- We updated to sidebar, header with the extra information and fields that we added to the activity.ts and fill them in stroe.
9- For joining to an activity, in the agent file we added a new endpoint to call api\activities\{id}\attend controller.
10- Then we add a new method in activityStore to use this endpoint. 
11- in the ActivityDetailedHeader we use this method in the OnClick join and cancell activity.
12- Now we want to update the create and edit pages of the activity. 
13- For cancelling activity in store we create cancel activity toggle method. 
14- For adding profile on hover over mouse, in the feature folder we added a new folder by name profile.
15- Then we add profilecard component and the we use it in activitylistitemattendee.
****************************************** End Of Section 15: Client Side Attendance *******************************
1- Chose a photo storage option. 
2- Adding a photo upload service. 
3- Using the cloudinary API which specialises an image storage in cloud. 
4- The first step is open nuget gallery and look for Cloudinary and install it on infrastructure project. 
5- Then we need to setup our project to have credentials to connect to Cloudinary.
6- In the API project, open appsetting json file and add required keys. Becuase it is exclouded to import to git. 
7- 











